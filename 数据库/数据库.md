# 数据库面试题

物理抽象、概念抽象、视图级抽象,内模式、模式、外模式的概念

数据独立性包括？
物理独立性：应用程序与物理存储独立。
逻辑独立性：应用程序与逻辑结构独立。
由二级映射实现。

什么是数据模型？
概念模型：信息模型，按用户观点来对数据和信息建模，用于数据库设计。
逻辑模型和物理模型：逻辑模型（关系模型等..用于数据库实现）和物理模型（对底层的抽象）
组成要素：数据结构、数据操作和数据完整性。

SQL语言包括数据定义、数据操纵(Data Manipulation),数据控制(Data Control)
数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等
数据操纵：Select ,insert,update,delete,
数据控制：grant,revoke

完整性约束：实体完整性（主属性不得为空）、参照完整性（参考的关系必须为空或者存在。遇到问题时的操作：拒绝执行（默认）、级联操作、设为空值）、用户定义完整性（CONSTRAINT和CHECK语句）。

三级模式结构？
外模式：子模式或用户模式。局部的。
模式：逻辑模式。数据库中全体数据的逻辑结构和特征描述。三级模式中的关键。
内模式：存储模式。

二级映像？
实现三个抽象层次的联系和转化。
外模式/模式映像：数据的逻辑独立性。
模式/内模式：数据的物理独立性。

候选码：某一属性或一组属性能唯一的标识一个元组，而其子集不能。
主属性：候选码中的属性。
全码、非码属性。

关系有三种类型：基本关系（基本表或基表）、查询表和视图表。

关系模式：关系的描述称为关系模式。

关系代数：传统的集合运算（交并差笛卡尔积） + 专门的关系运算。

选择运算：
$$ \sigma_F(R)=\{t|t\in R \wedge F(t) = ture \} $$
F是选择条件

投影运算（选择某几个列）：
$$ \prod_A(R)=\{t[A]|t \in R \} $$

连接运算（相当于join）：
打不出来.....

等值连接：条件是值相等
自然连接：相同的属性组，并且把结果中重复的列去掉。

外连接与内连接（对待悬浮元组的不同）
左外连接：保留右侧的悬浮元组。

数据库的安全机制：
存取控制：
自助存取控制：GRANT REVOKE
强制存取控制：主体许可证级别大于或等于客体许可证的密级才能够读取相应信息。主体许可证级别小于或等于客体密级时，才能写入信息。

审计

视图机制

数据加密

其他：推理控制、隐蔽信道。

什么是断言：
通过声明性断言来指定更具一般性的约束。定义涉及多个表后聚集操作的比较复杂的完整性约束。
CREATE ASSERTION <断言名> CHECK......

什么是触发器？
用于定义在关系表上的一类由事件驱动的特殊过程。
CREATE TRIGGER <触发器名>
{BEFORE|AFTER} <触发事件> ON 表名
REFERENCE NEW|OLD ROW AS<变量>
FOR EACH {ROW|STATEMENT}
[WHEN <触发事件>] <触发动作体>

不符合范式可能导致的问题：数据冗余、更新异常、插入异常、删除异常

第一范式：关系所有的分量都是原子类型。
第二范式：非主属性完全函数依赖于任何一个候选码。消除了非主属性对码的部分函数依赖。
第三范式：不存在传递函数依赖。消除了非主属性对码的传递函数依赖。
BC范式：消除了主属性对码的部分和传递函数依赖。
第四范式：消除了非平凡且非函数依赖的多值依赖。

E-R模型：实体关系模型。

存储过程：预编译，运行效率高、减少客户机和服务器的通行量。
CREATE OR REPLACE PROCEDURE <过程名(参数1， 参数2...)>
AS <过程化的SQL块>

什么是事务？ACID特性？
用户定义的一个数据库操作序列，要么全做，要么全不做。
原子性、一致性（全部事务都成功提交的时候处于一致性，不然两个账户钱不一样）、隔离性（不被其他事务干扰）、持续性（永久性，一旦提交改变是永久的。）。

并发控制的概念：
基本单位是事务。
可能带来的问题：丢失修改、不可重复读（幻影现象）、读脏数据。
常用技术：封锁、时间戳、乐观控制法、多版本并发控制。

封锁技术：排它锁（写锁）、共享锁（写锁）。

封锁协议？
一级封锁协议：修改前加写锁、事务结束释放。防止丢失修改，不能保证可重复读和不读脏数据。
二级封锁协议：一级的基础上，读前加读锁，读完释放。防止读脏数据。
三级封锁协议：一级的基础上，读前加读锁，事务结束释放。解决不可重复读。

并发调度的可串行性？
多个事务并发执行是正确的，当且仅当按顺序挨个执行的结果相同。可串行化调度。
充分条件：冲突（不同事务对于同一数据的读写或写写操作）可串行化。

保证并发调度的正确性？
两段锁：获得锁，扩展阶段。释放锁，收缩阶段。

视图：从一个或几个基本表中导出的表。虚表。行列子集视图（只操作一个表）。分组视图（带聚集函数和GROUPBY）。视图消解。不是所有的视图都是可更新的。

数据库中的索引？
B+树索引：叶节点存放索引的属性值和元组的指针。
散列索引：若干个桶，桶中存放索引的属性和元组的指针。精确查找快，模糊查找慢、不适用于排序、不适用于重复较多的列
位图索引：使用位图来表示的索引。占用空间小不适用于键值较多的列。不适用于更新操作频繁的列。

乐观锁和悲观锁？
悲观锁：认为自己操作数据的时候别人一定会修改，所以每次都会上锁。
乐观锁：与悲观锁相反，适用于读操作较多的情况，增大吞吐量。基于数据版本实现，就是给表加一个version字段来实现，每次更新时版本号加一，提交时进行对比，若提交时版本号大于之前读出的版本号，则视为过期数据。

drop、delete、trancate的区别？
删除表用drop、删除行用delete、trancate只删数据不删表结构
